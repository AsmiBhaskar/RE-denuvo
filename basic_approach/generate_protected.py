"""
Simple code obfuscator for learning purposes
Generates a protected version of the test target
"""

import re
import random
import string

def generate_random_name(length=8):
    """Generate a random variable name"""
    return 'var_' + ''.join(random.choices(string.ascii_letters + string.digits, k=length))

def obfuscate_strings(content):
    """Basic string obfuscation - XOR encode strings"""
    
    def encode_string(match):
        original = match.group(1)
        if len(original) < 3: 
            return match.group(0)
        
        key = random.randint(1, 255)
        encoded = []
        for char in original:
            encoded.append(str(ord(char) ^ key))
        
        var_name = generate_random_name()
        decode_code = f'''
    // Decoded string: {original}
    char {var_name}[{len(original)+1}];
    unsigned char {var_name}_data[] = {{{','.join(encoded)}}};
    for(int i = 0; i < {len(original)}; i++) {{
        {var_name}[i] = {var_name}_data[i] ^ {key};
    }}
    {var_name}[{len(original)}] = 0;
    '''
        
        return decode_code + f'\n    strcmp(input_key, {var_name})'
    
    
    content = re.sub(r'strcmp\(input_key, "([^"]+)"\)', encode_string, content)
    
    return content

def add_dummy_code(content):
    """Add dummy code to confuse static analysis"""
    
    dummy_functions = '''
// Dummy functions to confuse analysis
static void dummy_func_1() {
    volatile int x = 42;
    for(int i = 0; i < 1000; i++) {
        x = (x * 17) ^ (i & 0xFF);
    }
}

static void dummy_func_2() {
    volatile char buffer[256];
    memset(buffer, 0xAA, sizeof(buffer));
    for(int i = 0; i < 255; i++) {
        buffer[i] ^= (i * 3) & 0xFF;
    }
}

static int dummy_check() {
    return (time(NULL) & 1) ? 42 : 43;
}
'''
    
    
    include_end = content.find('\n\n')
    if include_end != -1:
        content = content[:include_end] + dummy_functions + content[include_end:]
    
    return content

def add_anti_debug_calls(content):
    """Add anti-debugging calls throughout the code"""
    
    anti_debug_code = '''
#ifdef _WIN32
#define ANTI_DEBUG_CHECK() if(IsDebuggerPresent()) exit(42)
#else  
#define ANTI_DEBUG_CHECK() do { \\
    if(ptrace(PTRACE_TRACEME, 0, 1, 0) == -1) exit(42); \\
} while(0)
#endif
'''
    
    
    content = anti_debug_code + '\n' + content
    
    
    sensitive_funcs = ['validate_license', 'calculate_score', 'premium_feature']
    
    for func in sensitive_funcs:
        
        pattern = f'(int|void)\\s+{func}\\s*\\([^{{]*\\)\\s*{{'
        replacement = f'\\g<0>\n    ANTI_DEBUG_CHECK();'
        content = re.sub(pattern, replacement, content)
    
    return content

def obfuscate_control_flow(content):
    """Basic control flow obfuscation"""
    
    
    def replace_if_with_switch(match):
        condition = match.group(1)
        true_branch = match.group(2)
        
        return f'''
    switch(({condition}) ? 1 : 0) {{
        case 1: {{{true_branch}
        }} break;
        default: break;
    }}'''
    
    
    content = re.sub(r'if\s*\(([^)]+)\)\s*\{([^}]+)\}', replace_if_with_switch, content)
    
    return content

def generate_protected_version():
    """Generate the protected version of test_target.c"""
    
    try:
        with open('test_target.c', 'r') as f:
            content = f.read()
    except FileNotFoundError:
        print("Error: test_target.c not found!")
        return
    
    print("Generating protected version...")
    
    
    content = add_dummy_code(content)
    content = add_anti_debug_calls(content)
    content = obfuscate_strings(content)
    
    
    protection_headers = '''
#ifdef _WIN32
#include <windows.h>
#include <psapi.h>
#else
#include <sys/ptrace.h>
#endif
'''
    
    
    content = content.replace('#include <time.h>', '#include <time.h>\n' + protection_headers)
    
    
    with open('test_target_protected.c', 'w') as f:
        f.write('''// GENERATED FILE - Protected version of test_target.c
// This file demonstrates basic software protection techniques
// Generated by protection generator script

''')
        f.write(content)
    
    print("Protected version generated as test_target_protected.c")
    print("Note: This is a basic example for learning purposes.")
    print("Real protection systems use much more sophisticated techniques.")

def create_analysis_guide():
    """Create a guide for analyzing the protected binary"""
    
    guide = '''# Analysis Guide

## Original vs Protected Binary Analysis

### 1. String Analysis
```bash
# Compare strings in both versions
strings test_target | grep -i "secret"
strings test_target_protected | grep -i "secret"
```

### 2. Symbol Analysis  
```bash
# Check exported symbols
nm test_target | grep -i "validate"
nm test_target_protected | grep -i "validate"
```

### 3. Disassembly Comparison
```bash
# Compare disassembly of key functions
objdump -d test_target | grep -A20 "validate_license"
objdump -d test_target_protected | grep -A20 "validate_license"
```

### 4. Static Analysis Tools
```bash
# Use Ghidra, IDA, or radare2 to analyze both versions
r2 -A test_target
r2 -A test_target_protected
```

### 5. Dynamic Analysis
```bash
# Debug the protected version
gdb test_target_protected
# Try setting breakpoints on sensitive functions
# Watch for anti-debugging countermeasures
```

## What to Look For

1. **String Obfuscation**: The secret key should be harder to find
2. **Control Flow**: More complex assembly due to switch statements  
3. **Anti-Debugging**: Ptrace/IsDebuggerPresent calls
4. **Symbol Stripping**: Fewer readable function names
5. **Dummy Code**: Additional functions that don't serve real purpose

## Learning Exercise

Try to:
1. Find the secret key in both versions
2. Patch the license check in both versions
3. Bypass the anti-debugging protection
4. Compare the difficulty of analysis between versions
'''
    
    with open('ANALYSIS_GUIDE.md', 'w') as f:
        f.write(guide)
    
    print("Analysis guide created as ANALYSIS_GUIDE.md")

if __name__ == '__main__':
    generate_protected_version()
    create_analysis_guide()
    print("\nNext steps:")
    print("1. Run 'make' to build all targets")
    print("2. Run 'make test' to test the protection system")
    print("3. Run 'make analyze' to see analysis of the unprotected binary")
    print("4. Compare the two versions using the analysis guide")